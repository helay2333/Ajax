<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
            // // 1. 指定回调函数的方式更加灵活:
            //  旧的: 必须在启动异步任务前指定
            //   promise: 启动异步任务 => 返回 promie 对象 => 给 promise 对象绑定回调函数 (甚至可以在异步任务结束后指定)
            //  2. 支持链式调用, 可以解决回调地狱问题 什么是回调地狱?
            //   回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函 数执行的条件
            //    回调地狱的缺点? 不便于阅读 / 不便于异常处理 
            //    解决方案? promise 链式调用 
            //    终极解决方案? async/await 
            // 成功的回调函数 
                function successCallback(result) {
                    console.log("声音文件创建成功: " + result);
                }
                // 失败的回调函数 
                function failureCallback(error) {
                    console.log("声音文件创建失败: " + error);
            }
                /* 1.1 使用纯回调函数 */ 
            //  先指定回调函数然后再启动异步任务
                createAudioFileAsync(audioSettings, successCallback, failureCallback) 
                /* 1.2. 使用 Promise */ 
            //  先就执行了异步任务
                const promise = createAudioFileAsync(audioSettings);
            //  然后甚至可以回调函数来说，可以在异步任务结束之前，甚至是异步任务结束过了一段时间都可以指定
                setTimeout(() => {
                    promise.then(successCallback, failureCallback); 
            }, 3000); 



            /*2.1. 回调地狱 */
            //  多个异步操作串联执行-第二个需要第一个回调的结果，第三个需要第二个的...
            doSomething(function(result) {
                doSomethingElse(result, function(newResult) {
                    doThirdThing(newResult, function(finalResult) {
                            console.log('Got the final result: ' + finalResult) 
                        }, failureCallback) 
                    }, failureCallback) 
            }, failureCallback) 
            /*2.2. 使用 promise 的链式调用解决回调地狱 */
            //  得到promise就说明启动了一个异步任务
            doSomething().then(function(result) {
                return doSomethingElse(result) //调用第二个promise,返回一个新的结果1
            }).then(function(newResult) {
                // 收到结果1
            return doThirdThing(newResult) 
            }).then(function(finalResult) {
            console.log('Got the final result: ' + finalResult) 
            }).catch(failureCallback)
            // 最后所有的异常都是交给catch处理的就不需要自己处理了,异常传透
            /*2.3. async/await: 回调地狱的终极解决方案 */
            async function request() {
                try {
                const result = await doSomething() 
                const newResult = await doSomethingElse(result)
                const finalResult = await doThirdThing(newResult)
                console.log('Got the final result: ' + finalResult)
                } catch (error) {
                    failureCallback(error)
                }
            }
    </script>
</body>
</html>